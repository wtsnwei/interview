#### 贪心算法秘籍

1. 贪心策略

   首先要确定贪心策略，选择当前看上去最好的一个方案。例如，挑选苹果，如果你认为个大的是最好的，那你每次都从苹果堆中拿一个最大。

2. 局部最优解

   根据贪心策略，一步一步地得到局部最优解。例如，第一次选一个最大的苹果放起来，记为 a~1~，第二次从剩下的苹果中选择最大的一个放起来，记为 a~2~，以此类推。

3. 把所有的局部最优解合成最优解。例如：挑选一些最好的苹果（a~1~，a~2~，...）。



#### 加勒比海盗船——最优装载问题

问题：有一天海盗们截获了一艘装满各种各样古董的货船，每一件古董都价值连城，一旦打碎就失去了它的价值。虽然海盗船足够大，但装载重量为 C，每件古董的重量为 w~i~，海盗们该如何把尽可能多数量的宝贝装上海盗船呢？

1. **问题分析**

   船的载重固定，那么优先把重量小的物品放进去，装的物品最多。采用重量最小者先装的贪心选择策略，从局部最优达到全局最优，从而产生最优装载问题的最优解。

2. **算法设计**

   * 当载重量为 c 时，w~i~ 越小，可装载的宝贝数量 n 越大。只要依次选择最小重量古董，直到不能再装为止。
   * 把 n 个古董的重量从小到大排序，然后根据贪心策略尽可能地选出前 i 个古董，直到不能继续装为止，此时达到最优。

3. **伪代码**

   1. 数据结构

      使用一维数组储存古董的重量：

      ``` python
      weight = [……]  # 一维数组存储古董的重量
      ```

   2. 按重量排序

         ```python
         weight.sort()  # 按古董重量升序排序
         ```

   3. 按照贪心策略找最优解
   
         ```python
         tmp = 0  # tmp代表装载到船上的古董的重量
         ans = 0  # ans记录已经装载的古董个数
         for i in range(n):
             tmp += weight[i]  # 加上该古董的重量
             if tmp<=c:
                 ans ++
             else:
                 break
         ```
   
4. **实战演练**

   ```python
   def blocks():
       c,n = eval(input("请输入载重量 c 及古董个数 n，中间用,分隔): "))
       print("载重量c及古董的个数n: {} {}".format(c, n))
   
       weight = list(eval(input("请输入每个古董的重量，用,分开: ")))
       print("每个古董的重量: {}".format(weight))
   
       weight.sort()  # 按古董重量升序排序
   
       tmp = 0  # tmp代表装载到船上的古董的重量
       ans = 0  # ans记录已经装载的古董个数
       for i in range(n):
           tmp += weight[i];
           if tmp<=c:
               ans += 1
           else:
               break
   
       print("能装入的古董最大数量为 ans={}".format(ans))
   
   if __name__ == "__main__":
       blocks()
   
   ```

   

#### 贪心算法之阿里巴巴与四十大盗——背包问题

有一天,阿里巴巴赶着一头毛驴上山砍柴。砍好柴准备下山时,远处突然出现一股烟尘,弥漫着直向上空飞扬,朝他这儿卷过来,而且越来越近。靠近以后,他才看清原来是一支马队,他们共有四十人,一个个年轻力壮、行动敏捷。一个首领模样的人背负沉重的鞍袋,从丛林中一直来到那个大石头跟前,喃喃地说道:“芝麻,开门吧!”随着那个头目的喊声,大石头前突然出现一道宽阔的门路,于是强盗们鱼贯而入。阿里巴巴待在树上观察他们,直到他们走得无影无踪之后,才从树上下来。他大声喊道:他小心翼翼地走了进去,一下子惊呆了,洞中堆满了财物,还有多得无法计数的金银珠宝,有的散堆在地区上,有的盛在皮袋中。突然看见这么多的金银财富,“芝麻,开门吧!”他的喊声刚落,洞门立刻打开了。阿里巴巴深信这肯定是一个强盗们数代经营、掠夺所积累起来的宝窟。为了让乡亲们开开眼界,见识一下这些宝物,他想一种宝物只拿一个,如果太重就用锤子凿开,但毛驴的运载能力是有限的,怎么才能用驴子运走最大价值的财宝分给穷人呢?阿里巴巴陷入沉思中……

1. **分析**

   假设山洞中有 n 中宝物，每种宝物有一定重量 w 和相应的价值 v，毛驴运载能力有限，只能运走 m 重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢？

   我们可以尝试贪心策略：每次选取单位重量价值最大的宝物，即性价比最高的宝物。

2. **算法设计**

   * 数据结构及初始化：将 n 种宝物的重量和价值存储载宝物对象中（包含重量、价值、性价比3个属性），同时求出每种宝物的性价比也存储在对应的对象中，最好组成一个由宝物对象组成的列表，并按照性价比从高到低排序。采用 sum 来存储毛驴能够运走的最大价值，初始化为0。
   * 根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择性价比高的物品，判断是否小于 m （毛驴载重能能力），如果小于 m，则放入，sum 加上当前宝物的价值，m 减去放入宝物的重量；如果不小于 m，则取该宝物的一部分 m*p[i]，m=0，程序结束。m 减少到0，则 sum 得到最大值。

3. **伪代码**

   * 数据结构定义

     ```python
     class Treasure(object):
         
         def __init__(self, w, v p):
             self.w = w  # 宝物的重量
             self.v = v  # 宝物的价值
             self.p = p  # 宝物的性价比
     ```

   * 性价比排序

     需要自定义比较函数，实现宝物性价比的降序排序

     ```python
     def compare(a, b):
         if a.p > b.p:
             return -1
         if a.p < b.p:
             return 1
         return 0
     
     import functools
     treasure_list.sort(key=functools.cmp_to_key(compare))  # 使用自定义的比较函数排序
     ```

   * 贪心算法求解

     ```python
     for i in range(n):
         if m>s[i].w:  # 如果宝物重量小于毛驴剩下的载运能力，及剩余容量
             sum += s[i].v
         else:  # 如果宝物重量大于毛驴剩下的载运能力，及剩余容量
             sum += m.s[i].p  # 进行宝物切割，使刚好达到驴子承重
             break
     ```

4. **实战演练**

   ```python
   import functools
   
   class Treasure(object):
   
       def __init__(self, w, v, p):
           self.w = w  # 宝物的重量
           self.v = v  # 宝物的价值
           self.p = p  # 宝物的性价比
   
   def compare(a, b):
       # 根据宝物的价值从小到大排序
       if a.p > b.p:
           return -1
       if a.p < b.p:
           return 1
       return 0
   
   def main():
       n = eval(input("请输入宝物的数量n："))
       m = eval(input("请输入毛驴的承重能力m："))
   
       t_list = []
   
       for i in range(n):
           w,v = eval(input("请输入宝物的重量和价值，用逗号“,”分隔："))
           t = Treasure(w, v, v/w)  # 构造宝物对象
           t_list.append(t)  # 将宝物对象加入到列表中
   
       t_list.sort(key=functools.cmp_to_key(compare))
       sum = 0.0  # sum表示贪心记录运走宝物的价值之和
       for i in range(n):
           if m > t_list[i].w:  # 如果宝物的重量小于毛驴剩余载重能力
               m -= t_list[i].w
               sum += t_list[i].v
           else:
               sum += m*t_list[i].p  # 剩余部分
               break
       print("输入宝物的最大价值为：{}".format(sum))
   
   if __name__ == '__main__':
       main()
   ```

   
